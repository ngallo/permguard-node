// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "proto/v1/pdp.proto" (package "policydecisionpoint", syntax proto3)
// tslint:disable
//
// Copyright 2025 Nitro Agility S.r.l.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Struct } from "../../google/protobuf/struct";
/**
 * PolicyStore is the location where policies are maintained.
 *
 * @generated from protobuf message policydecisionpoint.PolicyStore
 */
export interface PolicyStore {
    /**
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * @generated from protobuf field: string ID = 2 [json_name = "ID"];
     */
    iD: string;
}
/**
 * Principal represents the entity making the request.
 *
 * @generated from protobuf message policydecisionpoint.Principal
 */
export interface Principal {
    /**
     * @generated from protobuf field: string Type = 1 [json_name = "Type"];
     */
    type: string;
    /**
     * @generated from protobuf field: string ID = 2 [json_name = "ID"];
     */
    iD: string;
    /**
     * @generated from protobuf field: optional string Source = 3 [json_name = "Source"];
     */
    source?: string;
    /**
     * @generated from protobuf field: optional string IdentityToken = 4 [json_name = "IdentityToken"];
     */
    identityToken?: string;
    /**
     * @generated from protobuf field: optional string AccessToken = 5 [json_name = "AccessToken"];
     */
    accessToken?: string;
}
/**
 * Entities represent the entities provided in the context for the authorization decision.
 *
 * @generated from protobuf message policydecisionpoint.Entities
 */
export interface Entities {
    /**
     * @generated from protobuf field: string Schema = 1 [json_name = "Schema"];
     */
    schema: string;
    /**
     * @generated from protobuf field: repeated google.protobuf.Struct Items = 2 [json_name = "Items"];
     */
    items: Struct[];
}
/**
 * Subject is the entity on which the authorization decision is made.
 *
 * @generated from protobuf message policydecisionpoint.Subject
 */
export interface Subject {
    /**
     * @generated from protobuf field: string Type = 1 [json_name = "Type"];
     */
    type: string;
    /**
     * @generated from protobuf field: string ID = 2 [json_name = "ID"];
     */
    iD: string;
    /**
     * @generated from protobuf field: optional string Source = 3 [json_name = "Source"];
     */
    source?: string;
    /**
     * @generated from protobuf field: optional google.protobuf.Struct Properties = 4 [json_name = "Properties"];
     */
    properties?: Struct;
}
/**
 * Resource is the entity on which the authorization decision is made.
 *
 * @generated from protobuf message policydecisionpoint.Resource
 */
export interface Resource {
    /**
     * @generated from protobuf field: string Type = 1 [json_name = "Type"];
     */
    type: string;
    /**
     * @generated from protobuf field: string ID = 2 [json_name = "ID"];
     */
    iD: string;
    /**
     * @generated from protobuf field: optional google.protobuf.Struct Properties = 3 [json_name = "Properties"];
     */
    properties?: Struct;
}
/**
 * Action is the operation on which the authorization decision is made.
 *
 * @generated from protobuf message policydecisionpoint.Action
 */
export interface Action {
    /**
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * @generated from protobuf field: optional google.protobuf.Struct Properties = 2 [json_name = "Properties"];
     */
    properties?: Struct;
}
// AuthorizationCheck Request

/**
 * AuthorizationModelRequest is the input context for making the authorization decision.
 *
 * @generated from protobuf message policydecisionpoint.AuthorizationModelRequest
 */
export interface AuthorizationModelRequest {
    /**
     * @generated from protobuf field: int64 ZoneID = 1 [json_name = "ZoneID"];
     */
    zoneID: bigint;
    /**
     * @generated from protobuf field: policydecisionpoint.PolicyStore PolicyStore = 2 [json_name = "PolicyStore"];
     */
    policyStore?: PolicyStore;
    /**
     * @generated from protobuf field: optional policydecisionpoint.Principal Principal = 3 [json_name = "Principal"];
     */
    principal?: Principal;
    /**
     * @generated from protobuf field: optional policydecisionpoint.Entities Entities = 4 [json_name = "Entities"];
     */
    entities?: Entities;
}
/**
 * EvaluationRequest represents the request to evaluate the authorization decision.
 *
 * @generated from protobuf message policydecisionpoint.EvaluationRequest
 */
export interface EvaluationRequest {
    /**
     * @generated from protobuf field: optional string RequestID = 1 [json_name = "RequestID"];
     */
    requestID?: string;
    /**
     * @generated from protobuf field: optional policydecisionpoint.Subject Subject = 2 [json_name = "Subject"];
     */
    subject?: Subject;
    /**
     * @generated from protobuf field: optional policydecisionpoint.Resource Resource = 3 [json_name = "Resource"];
     */
    resource?: Resource;
    /**
     * @generated from protobuf field: optional policydecisionpoint.Action Action = 4 [json_name = "Action"];
     */
    action?: Action;
    /**
     * @generated from protobuf field: optional google.protobuf.Struct Context = 5 [json_name = "Context"];
     */
    context?: Struct;
}
/**
 * AuthorizationCheckRequest represents the request to perform an authorization decision.
 *
 * @generated from protobuf message policydecisionpoint.AuthorizationCheckRequest
 */
export interface AuthorizationCheckRequest {
    /**
     * @generated from protobuf field: policydecisionpoint.AuthorizationModelRequest AuthorizationModel = 1 [json_name = "AuthorizationModel"];
     */
    authorizationModel?: AuthorizationModelRequest;
    /**
     * @generated from protobuf field: optional string RequestID = 2 [json_name = "RequestID"];
     */
    requestID?: string;
    /**
     * @generated from protobuf field: optional policydecisionpoint.Subject Subject = 3 [json_name = "Subject"];
     */
    subject?: Subject;
    /**
     * @generated from protobuf field: optional policydecisionpoint.Resource Resource = 4 [json_name = "Resource"];
     */
    resource?: Resource;
    /**
     * @generated from protobuf field: optional policydecisionpoint.Action Action = 5 [json_name = "Action"];
     */
    action?: Action;
    /**
     * @generated from protobuf field: optional google.protobuf.Struct Context = 6 [json_name = "Context"];
     */
    context?: Struct;
    /**
     * @generated from protobuf field: repeated policydecisionpoint.EvaluationRequest Evaluations = 7 [json_name = "Evaluations"];
     */
    evaluations: EvaluationRequest[];
}
// AuthorizationCheck Response

/**
 * ReasonResponse provides the rationale for the response.
 *
 * @generated from protobuf message policydecisionpoint.ReasonResponse
 */
export interface ReasonResponse {
    /**
     * @generated from protobuf field: string Code = 1 [json_name = "Code"];
     */
    code: string;
    /**
     * @generated from protobuf field: string Message = 2 [json_name = "Message"];
     */
    message: string;
}
/**
 * ContextResponse represents the context included in the response.
 *
 * @generated from protobuf message policydecisionpoint.ContextResponse
 */
export interface ContextResponse {
    /**
     * @generated from protobuf field: string ID = 1 [json_name = "ID"];
     */
    iD: string;
    /**
     * @generated from protobuf field: policydecisionpoint.ReasonResponse ReasonAdmin = 2 [json_name = "ReasonAdmin"];
     */
    reasonAdmin?: ReasonResponse;
    /**
     * @generated from protobuf field: policydecisionpoint.ReasonResponse ReasonUser = 3 [json_name = "ReasonUser"];
     */
    reasonUser?: ReasonResponse;
}
/**
 * EvaluationResponse represents the result of the evaluation process.
 *
 * @generated from protobuf message policydecisionpoint.EvaluationResponse
 */
export interface EvaluationResponse {
    /**
     * @generated from protobuf field: bool Decision = 1 [json_name = "Decision"];
     */
    decision: boolean;
    /**
     * @generated from protobuf field: optional string RequestID = 2 [json_name = "RequestID"];
     */
    requestID?: string;
    /**
     * @generated from protobuf field: optional policydecisionpoint.ContextResponse Context = 3 [json_name = "Context"];
     */
    context?: ContextResponse;
}
/**
 * AuthorizationCheckResponse represents the outcome of the authorization decision.
 *
 * @generated from protobuf message policydecisionpoint.AuthorizationCheckResponse
 */
export interface AuthorizationCheckResponse {
    /**
     * @generated from protobuf field: bool Decision = 1 [json_name = "Decision"];
     */
    decision: boolean;
    /**
     * @generated from protobuf field: optional string RequestID = 2 [json_name = "RequestID"];
     */
    requestID?: string;
    /**
     * @generated from protobuf field: optional policydecisionpoint.ContextResponse Context = 3 [json_name = "Context"];
     */
    context?: ContextResponse;
    /**
     * @generated from protobuf field: repeated policydecisionpoint.EvaluationResponse Evaluations = 4 [json_name = "Evaluations"];
     */
    evaluations: EvaluationResponse[];
}
// @generated message type with reflection information, may provide speed optimized methods
class PolicyStore$Type extends MessageType<PolicyStore> {
    constructor() {
        super("policydecisionpoint.PolicyStore", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ID", kind: "scalar", jsonName: "ID", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PolicyStore>): PolicyStore {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.iD = "";
        if (value !== undefined)
            reflectionMergePartial<PolicyStore>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PolicyStore): PolicyStore {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string ID = 2 [json_name = "ID"];*/ 2:
                    message.iD = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PolicyStore, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string ID = 2 [json_name = "ID"]; */
        if (message.iD !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.iD);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message policydecisionpoint.PolicyStore
 */
export const PolicyStore = new PolicyStore$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Principal$Type extends MessageType<Principal> {
    constructor() {
        super("policydecisionpoint.Principal", [
            { no: 1, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ID", kind: "scalar", jsonName: "ID", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Source", kind: "scalar", jsonName: "Source", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "IdentityToken", kind: "scalar", jsonName: "IdentityToken", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "AccessToken", kind: "scalar", jsonName: "AccessToken", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Principal>): Principal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.iD = "";
        if (value !== undefined)
            reflectionMergePartial<Principal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Principal): Principal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Type = 1 [json_name = "Type"];*/ 1:
                    message.type = reader.string();
                    break;
                case /* string ID = 2 [json_name = "ID"];*/ 2:
                    message.iD = reader.string();
                    break;
                case /* optional string Source = 3 [json_name = "Source"];*/ 3:
                    message.source = reader.string();
                    break;
                case /* optional string IdentityToken = 4 [json_name = "IdentityToken"];*/ 4:
                    message.identityToken = reader.string();
                    break;
                case /* optional string AccessToken = 5 [json_name = "AccessToken"];*/ 5:
                    message.accessToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Principal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Type = 1 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string ID = 2 [json_name = "ID"]; */
        if (message.iD !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.iD);
        /* optional string Source = 3 [json_name = "Source"]; */
        if (message.source !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.source);
        /* optional string IdentityToken = 4 [json_name = "IdentityToken"]; */
        if (message.identityToken !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.identityToken);
        /* optional string AccessToken = 5 [json_name = "AccessToken"]; */
        if (message.accessToken !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.accessToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message policydecisionpoint.Principal
 */
export const Principal = new Principal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Entities$Type extends MessageType<Entities> {
    constructor() {
        super("policydecisionpoint.Entities", [
            { no: 1, name: "Schema", kind: "scalar", jsonName: "Schema", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Items", kind: "message", jsonName: "Items", repeat: 1 /*RepeatType.PACKED*/, T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<Entities>): Entities {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schema = "";
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<Entities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Entities): Entities {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Schema = 1 [json_name = "Schema"];*/ 1:
                    message.schema = reader.string();
                    break;
                case /* repeated google.protobuf.Struct Items = 2 [json_name = "Items"];*/ 2:
                    message.items.push(Struct.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Entities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Schema = 1 [json_name = "Schema"]; */
        if (message.schema !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schema);
        /* repeated google.protobuf.Struct Items = 2 [json_name = "Items"]; */
        for (let i = 0; i < message.items.length; i++)
            Struct.internalBinaryWrite(message.items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message policydecisionpoint.Entities
 */
export const Entities = new Entities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Subject$Type extends MessageType<Subject> {
    constructor() {
        super("policydecisionpoint.Subject", [
            { no: 1, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ID", kind: "scalar", jsonName: "ID", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Source", kind: "scalar", jsonName: "Source", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "Properties", kind: "message", jsonName: "Properties", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<Subject>): Subject {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.iD = "";
        if (value !== undefined)
            reflectionMergePartial<Subject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Subject): Subject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Type = 1 [json_name = "Type"];*/ 1:
                    message.type = reader.string();
                    break;
                case /* string ID = 2 [json_name = "ID"];*/ 2:
                    message.iD = reader.string();
                    break;
                case /* optional string Source = 3 [json_name = "Source"];*/ 3:
                    message.source = reader.string();
                    break;
                case /* optional google.protobuf.Struct Properties = 4 [json_name = "Properties"];*/ 4:
                    message.properties = Struct.internalBinaryRead(reader, reader.uint32(), options, message.properties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Subject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Type = 1 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string ID = 2 [json_name = "ID"]; */
        if (message.iD !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.iD);
        /* optional string Source = 3 [json_name = "Source"]; */
        if (message.source !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.source);
        /* optional google.protobuf.Struct Properties = 4 [json_name = "Properties"]; */
        if (message.properties)
            Struct.internalBinaryWrite(message.properties, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message policydecisionpoint.Subject
 */
export const Subject = new Subject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Resource$Type extends MessageType<Resource> {
    constructor() {
        super("policydecisionpoint.Resource", [
            { no: 1, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ID", kind: "scalar", jsonName: "ID", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Properties", kind: "message", jsonName: "Properties", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<Resource>): Resource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.iD = "";
        if (value !== undefined)
            reflectionMergePartial<Resource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Resource): Resource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Type = 1 [json_name = "Type"];*/ 1:
                    message.type = reader.string();
                    break;
                case /* string ID = 2 [json_name = "ID"];*/ 2:
                    message.iD = reader.string();
                    break;
                case /* optional google.protobuf.Struct Properties = 3 [json_name = "Properties"];*/ 3:
                    message.properties = Struct.internalBinaryRead(reader, reader.uint32(), options, message.properties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Resource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Type = 1 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string ID = 2 [json_name = "ID"]; */
        if (message.iD !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.iD);
        /* optional google.protobuf.Struct Properties = 3 [json_name = "Properties"]; */
        if (message.properties)
            Struct.internalBinaryWrite(message.properties, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message policydecisionpoint.Resource
 */
export const Resource = new Resource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Action$Type extends MessageType<Action> {
    constructor() {
        super("policydecisionpoint.Action", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Properties", kind: "message", jsonName: "Properties", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<Action>): Action {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Action>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Action): Action {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* optional google.protobuf.Struct Properties = 2 [json_name = "Properties"];*/ 2:
                    message.properties = Struct.internalBinaryRead(reader, reader.uint32(), options, message.properties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Action, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional google.protobuf.Struct Properties = 2 [json_name = "Properties"]; */
        if (message.properties)
            Struct.internalBinaryWrite(message.properties, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message policydecisionpoint.Action
 */
export const Action = new Action$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizationModelRequest$Type extends MessageType<AuthorizationModelRequest> {
    constructor() {
        super("policydecisionpoint.AuthorizationModelRequest", [
            { no: 1, name: "ZoneID", kind: "scalar", jsonName: "ZoneID", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "PolicyStore", kind: "message", jsonName: "PolicyStore", T: () => PolicyStore },
            { no: 3, name: "Principal", kind: "message", jsonName: "Principal", T: () => Principal },
            { no: 4, name: "Entities", kind: "message", jsonName: "Entities", T: () => Entities }
        ]);
    }
    create(value?: PartialMessage<AuthorizationModelRequest>): AuthorizationModelRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.zoneID = 0n;
        if (value !== undefined)
            reflectionMergePartial<AuthorizationModelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorizationModelRequest): AuthorizationModelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 ZoneID = 1 [json_name = "ZoneID"];*/ 1:
                    message.zoneID = reader.int64().toBigInt();
                    break;
                case /* policydecisionpoint.PolicyStore PolicyStore = 2 [json_name = "PolicyStore"];*/ 2:
                    message.policyStore = PolicyStore.internalBinaryRead(reader, reader.uint32(), options, message.policyStore);
                    break;
                case /* optional policydecisionpoint.Principal Principal = 3 [json_name = "Principal"];*/ 3:
                    message.principal = Principal.internalBinaryRead(reader, reader.uint32(), options, message.principal);
                    break;
                case /* optional policydecisionpoint.Entities Entities = 4 [json_name = "Entities"];*/ 4:
                    message.entities = Entities.internalBinaryRead(reader, reader.uint32(), options, message.entities);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthorizationModelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 ZoneID = 1 [json_name = "ZoneID"]; */
        if (message.zoneID !== 0n)
            writer.tag(1, WireType.Varint).int64(message.zoneID);
        /* policydecisionpoint.PolicyStore PolicyStore = 2 [json_name = "PolicyStore"]; */
        if (message.policyStore)
            PolicyStore.internalBinaryWrite(message.policyStore, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional policydecisionpoint.Principal Principal = 3 [json_name = "Principal"]; */
        if (message.principal)
            Principal.internalBinaryWrite(message.principal, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional policydecisionpoint.Entities Entities = 4 [json_name = "Entities"]; */
        if (message.entities)
            Entities.internalBinaryWrite(message.entities, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message policydecisionpoint.AuthorizationModelRequest
 */
export const AuthorizationModelRequest = new AuthorizationModelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvaluationRequest$Type extends MessageType<EvaluationRequest> {
    constructor() {
        super("policydecisionpoint.EvaluationRequest", [
            { no: 1, name: "RequestID", kind: "scalar", jsonName: "RequestID", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Subject", kind: "message", jsonName: "Subject", T: () => Subject },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => Resource },
            { no: 4, name: "Action", kind: "message", jsonName: "Action", T: () => Action },
            { no: 5, name: "Context", kind: "message", jsonName: "Context", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<EvaluationRequest>): EvaluationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EvaluationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvaluationRequest): EvaluationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string RequestID = 1 [json_name = "RequestID"];*/ 1:
                    message.requestID = reader.string();
                    break;
                case /* optional policydecisionpoint.Subject Subject = 2 [json_name = "Subject"];*/ 2:
                    message.subject = Subject.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* optional policydecisionpoint.Resource Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = Resource.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* optional policydecisionpoint.Action Action = 4 [json_name = "Action"];*/ 4:
                    message.action = Action.internalBinaryRead(reader, reader.uint32(), options, message.action);
                    break;
                case /* optional google.protobuf.Struct Context = 5 [json_name = "Context"];*/ 5:
                    message.context = Struct.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvaluationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string RequestID = 1 [json_name = "RequestID"]; */
        if (message.requestID !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.requestID);
        /* optional policydecisionpoint.Subject Subject = 2 [json_name = "Subject"]; */
        if (message.subject)
            Subject.internalBinaryWrite(message.subject, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional policydecisionpoint.Resource Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            Resource.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional policydecisionpoint.Action Action = 4 [json_name = "Action"]; */
        if (message.action)
            Action.internalBinaryWrite(message.action, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.Struct Context = 5 [json_name = "Context"]; */
        if (message.context)
            Struct.internalBinaryWrite(message.context, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message policydecisionpoint.EvaluationRequest
 */
export const EvaluationRequest = new EvaluationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizationCheckRequest$Type extends MessageType<AuthorizationCheckRequest> {
    constructor() {
        super("policydecisionpoint.AuthorizationCheckRequest", [
            { no: 1, name: "AuthorizationModel", kind: "message", jsonName: "AuthorizationModel", T: () => AuthorizationModelRequest },
            { no: 2, name: "RequestID", kind: "scalar", jsonName: "RequestID", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Subject", kind: "message", jsonName: "Subject", T: () => Subject },
            { no: 4, name: "Resource", kind: "message", jsonName: "Resource", T: () => Resource },
            { no: 5, name: "Action", kind: "message", jsonName: "Action", T: () => Action },
            { no: 6, name: "Context", kind: "message", jsonName: "Context", T: () => Struct },
            { no: 7, name: "Evaluations", kind: "message", jsonName: "Evaluations", repeat: 1 /*RepeatType.PACKED*/, T: () => EvaluationRequest }
        ]);
    }
    create(value?: PartialMessage<AuthorizationCheckRequest>): AuthorizationCheckRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.evaluations = [];
        if (value !== undefined)
            reflectionMergePartial<AuthorizationCheckRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorizationCheckRequest): AuthorizationCheckRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* policydecisionpoint.AuthorizationModelRequest AuthorizationModel = 1 [json_name = "AuthorizationModel"];*/ 1:
                    message.authorizationModel = AuthorizationModelRequest.internalBinaryRead(reader, reader.uint32(), options, message.authorizationModel);
                    break;
                case /* optional string RequestID = 2 [json_name = "RequestID"];*/ 2:
                    message.requestID = reader.string();
                    break;
                case /* optional policydecisionpoint.Subject Subject = 3 [json_name = "Subject"];*/ 3:
                    message.subject = Subject.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* optional policydecisionpoint.Resource Resource = 4 [json_name = "Resource"];*/ 4:
                    message.resource = Resource.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* optional policydecisionpoint.Action Action = 5 [json_name = "Action"];*/ 5:
                    message.action = Action.internalBinaryRead(reader, reader.uint32(), options, message.action);
                    break;
                case /* optional google.protobuf.Struct Context = 6 [json_name = "Context"];*/ 6:
                    message.context = Struct.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* repeated policydecisionpoint.EvaluationRequest Evaluations = 7 [json_name = "Evaluations"];*/ 7:
                    message.evaluations.push(EvaluationRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthorizationCheckRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* policydecisionpoint.AuthorizationModelRequest AuthorizationModel = 1 [json_name = "AuthorizationModel"]; */
        if (message.authorizationModel)
            AuthorizationModelRequest.internalBinaryWrite(message.authorizationModel, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string RequestID = 2 [json_name = "RequestID"]; */
        if (message.requestID !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.requestID);
        /* optional policydecisionpoint.Subject Subject = 3 [json_name = "Subject"]; */
        if (message.subject)
            Subject.internalBinaryWrite(message.subject, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional policydecisionpoint.Resource Resource = 4 [json_name = "Resource"]; */
        if (message.resource)
            Resource.internalBinaryWrite(message.resource, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional policydecisionpoint.Action Action = 5 [json_name = "Action"]; */
        if (message.action)
            Action.internalBinaryWrite(message.action, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.Struct Context = 6 [json_name = "Context"]; */
        if (message.context)
            Struct.internalBinaryWrite(message.context, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated policydecisionpoint.EvaluationRequest Evaluations = 7 [json_name = "Evaluations"]; */
        for (let i = 0; i < message.evaluations.length; i++)
            EvaluationRequest.internalBinaryWrite(message.evaluations[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message policydecisionpoint.AuthorizationCheckRequest
 */
export const AuthorizationCheckRequest = new AuthorizationCheckRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReasonResponse$Type extends MessageType<ReasonResponse> {
    constructor() {
        super("policydecisionpoint.ReasonResponse", [
            { no: 1, name: "Code", kind: "scalar", jsonName: "Code", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Message", kind: "scalar", jsonName: "Message", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReasonResponse>): ReasonResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ReasonResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReasonResponse): ReasonResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Code = 1 [json_name = "Code"];*/ 1:
                    message.code = reader.string();
                    break;
                case /* string Message = 2 [json_name = "Message"];*/ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReasonResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Code = 1 [json_name = "Code"]; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* string Message = 2 [json_name = "Message"]; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message policydecisionpoint.ReasonResponse
 */
export const ReasonResponse = new ReasonResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContextResponse$Type extends MessageType<ContextResponse> {
    constructor() {
        super("policydecisionpoint.ContextResponse", [
            { no: 1, name: "ID", kind: "scalar", jsonName: "ID", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ReasonAdmin", kind: "message", jsonName: "ReasonAdmin", T: () => ReasonResponse },
            { no: 3, name: "ReasonUser", kind: "message", jsonName: "ReasonUser", T: () => ReasonResponse }
        ]);
    }
    create(value?: PartialMessage<ContextResponse>): ContextResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iD = "";
        if (value !== undefined)
            reflectionMergePartial<ContextResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContextResponse): ContextResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ID = 1 [json_name = "ID"];*/ 1:
                    message.iD = reader.string();
                    break;
                case /* policydecisionpoint.ReasonResponse ReasonAdmin = 2 [json_name = "ReasonAdmin"];*/ 2:
                    message.reasonAdmin = ReasonResponse.internalBinaryRead(reader, reader.uint32(), options, message.reasonAdmin);
                    break;
                case /* policydecisionpoint.ReasonResponse ReasonUser = 3 [json_name = "ReasonUser"];*/ 3:
                    message.reasonUser = ReasonResponse.internalBinaryRead(reader, reader.uint32(), options, message.reasonUser);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ContextResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ID = 1 [json_name = "ID"]; */
        if (message.iD !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.iD);
        /* policydecisionpoint.ReasonResponse ReasonAdmin = 2 [json_name = "ReasonAdmin"]; */
        if (message.reasonAdmin)
            ReasonResponse.internalBinaryWrite(message.reasonAdmin, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* policydecisionpoint.ReasonResponse ReasonUser = 3 [json_name = "ReasonUser"]; */
        if (message.reasonUser)
            ReasonResponse.internalBinaryWrite(message.reasonUser, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message policydecisionpoint.ContextResponse
 */
export const ContextResponse = new ContextResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvaluationResponse$Type extends MessageType<EvaluationResponse> {
    constructor() {
        super("policydecisionpoint.EvaluationResponse", [
            { no: 1, name: "Decision", kind: "scalar", jsonName: "Decision", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "RequestID", kind: "scalar", jsonName: "RequestID", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Context", kind: "message", jsonName: "Context", T: () => ContextResponse }
        ]);
    }
    create(value?: PartialMessage<EvaluationResponse>): EvaluationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.decision = false;
        if (value !== undefined)
            reflectionMergePartial<EvaluationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvaluationResponse): EvaluationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Decision = 1 [json_name = "Decision"];*/ 1:
                    message.decision = reader.bool();
                    break;
                case /* optional string RequestID = 2 [json_name = "RequestID"];*/ 2:
                    message.requestID = reader.string();
                    break;
                case /* optional policydecisionpoint.ContextResponse Context = 3 [json_name = "Context"];*/ 3:
                    message.context = ContextResponse.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvaluationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Decision = 1 [json_name = "Decision"]; */
        if (message.decision !== false)
            writer.tag(1, WireType.Varint).bool(message.decision);
        /* optional string RequestID = 2 [json_name = "RequestID"]; */
        if (message.requestID !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.requestID);
        /* optional policydecisionpoint.ContextResponse Context = 3 [json_name = "Context"]; */
        if (message.context)
            ContextResponse.internalBinaryWrite(message.context, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message policydecisionpoint.EvaluationResponse
 */
export const EvaluationResponse = new EvaluationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizationCheckResponse$Type extends MessageType<AuthorizationCheckResponse> {
    constructor() {
        super("policydecisionpoint.AuthorizationCheckResponse", [
            { no: 1, name: "Decision", kind: "scalar", jsonName: "Decision", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "RequestID", kind: "scalar", jsonName: "RequestID", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Context", kind: "message", jsonName: "Context", T: () => ContextResponse },
            { no: 4, name: "Evaluations", kind: "message", jsonName: "Evaluations", repeat: 1 /*RepeatType.PACKED*/, T: () => EvaluationResponse }
        ]);
    }
    create(value?: PartialMessage<AuthorizationCheckResponse>): AuthorizationCheckResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.decision = false;
        message.evaluations = [];
        if (value !== undefined)
            reflectionMergePartial<AuthorizationCheckResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorizationCheckResponse): AuthorizationCheckResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Decision = 1 [json_name = "Decision"];*/ 1:
                    message.decision = reader.bool();
                    break;
                case /* optional string RequestID = 2 [json_name = "RequestID"];*/ 2:
                    message.requestID = reader.string();
                    break;
                case /* optional policydecisionpoint.ContextResponse Context = 3 [json_name = "Context"];*/ 3:
                    message.context = ContextResponse.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* repeated policydecisionpoint.EvaluationResponse Evaluations = 4 [json_name = "Evaluations"];*/ 4:
                    message.evaluations.push(EvaluationResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthorizationCheckResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Decision = 1 [json_name = "Decision"]; */
        if (message.decision !== false)
            writer.tag(1, WireType.Varint).bool(message.decision);
        /* optional string RequestID = 2 [json_name = "RequestID"]; */
        if (message.requestID !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.requestID);
        /* optional policydecisionpoint.ContextResponse Context = 3 [json_name = "Context"]; */
        if (message.context)
            ContextResponse.internalBinaryWrite(message.context, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated policydecisionpoint.EvaluationResponse Evaluations = 4 [json_name = "Evaluations"]; */
        for (let i = 0; i < message.evaluations.length; i++)
            EvaluationResponse.internalBinaryWrite(message.evaluations[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message policydecisionpoint.AuthorizationCheckResponse
 */
export const AuthorizationCheckResponse = new AuthorizationCheckResponse$Type();
/**
 * @generated ServiceType for protobuf service policydecisionpoint.V1PDPService
 */
export const V1PDPService = new ServiceType("policydecisionpoint.V1PDPService", [
    { name: "AuthorizationCheck", options: {}, I: AuthorizationCheckRequest, O: AuthorizationCheckResponse }
]);
